#!/bin/bash
#
# Having this anywhere in your $PATH (~/bin is recommended) will allow git to
# to see it and, and thus, you'll be able to do `git refresh`.
#
# TODO: it'd be nice to replace the for with a parallel call
# TODO: to effect the above, would need to be able on non-local repos
#         i.e. set: --work-tree={repo} --git-dir={repo}/.git
#

#set -x
set -euo pipefail

repo_has_remotes() {
    local target=$1
    local remotes_found

    remotes_found=$(grep '^\[remote' ${target}/.git/config 2>/dev/null | wc -l)
    [[ ${remotes_found} -gt 0 ]]
}

find_repos() {
    # list returned is relative to base_dir
    local base_dir=$1

    find ${base_dir} -name '.git' -type d -depth 2 \
        | awk -F/ '{print $5}'
}

on_branch_master() {
    local target=$1

    grep '^ref: refs/heads/master$' $1/.git/HEAD > /dev/null 2>&1

    [[ $? -eq 0 ]]
}

main() {
    local base_dir=$1
    local repo
    local repo_path
    local fetch_output

    for repo in $(find_repos ${base_dir})
    do
        repo_path="${base_dir}/${repo}"

        repo_has_remotes $repo_path || continue

        cd ${repo_path}

        fetch_output=$(git fetch 2>&1)

        if [[ "$fetch_output" != "" ]]
        then
            # found something to fetch
            echo "Processing ${repo}:"
            echo "${fetch_output}"

            if $(on_branch_master ${repo_path})
            then
                # try to update master
                git pull >/dev/null 2>&1 &
            fi
        fi
    done
}

main ${1:-~/Workspace}
